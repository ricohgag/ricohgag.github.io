+++
title = 'DDIA-Part3: 数据存储与检索'
date = 2020-11-09T11:14:33+08:00
draft = true
+++

## 数据库核心：数据结构

1. 文件结构，每行存储了key-value结构。增加新内容追加到文件尾部。旧版本的值不会被覆盖，寻找最后一次出现的键为最新的值。避免用尽磁盘，将追加的文件分为多段，将之前已经写入完成的段压缩（同key值只保留最后一个）。

### 哈希索引

哈希索引是key-value类型的索引，将追加文件中的key-文件偏移量（存储位置）缓存到内存中。也是Bitcask的核心做法。适合每个键的值频繁更新的场景。

**哈希索引缺点**

- 哈希表索引必须全部放入内存，内存容量决定了键的多少。但在磁盘上维护hashmap需要大量的随机访问IO，性能很差。

- 区间查询效率不高，只能逐个查询每一个键比对。

### SSTables和LSM-Tree

**SSTalbes（排序字符表**）：**LevelDB**和**RocksDB**

要求key-value对的顺序按键排序，且每个合并的段文件中每个键只能出现一次。

- 合并段更简单高效，两个段文件合并，当出现重复的键值时，采用后面时间创建的段文件中的值。

- 在文件中查找特定的键时，不需要在内存中保存所有键的索引，只需要保存稀疏的区间索引。可以得到特定键的前和后键的偏移地址，可以从前往后直到找到特定的键或特定键后面的键（没有此键）。

优化：可以按稀疏索引的区间将key-value值保存到一个块中，稀疏索引的每个条目执行压缩块的开头。可以减少磁盘IO次数。

**SSTalbes（排序字符表**）：**LevelDB**和**RocksDB**

要求key-value对的顺序按键排序，且每个合并的段文件中每个键只能出现一次。

- 合并段更简单高效，两个段文件合并，当出现重复的键值时，采用后面时间创建的段文件中的值。

- 在文件中查找特定的键时，不需要在内存中保存所有键的索引，只需要保存稀疏的区间索引。可以得到特定键的前和后键的偏移地址，可以从前往后直到找到特定的键或特定键后面的键（没有此键）。

优化：可以按稀疏索引的区间将key-value值保存到一个块中，稀疏索引的每个条目执行压缩块的开头。可以减少磁盘IO次数。

**构建和维护SSTables**

使用常用的内存排序数据结构（如红黑树或AVL数）保证任意顺序插入键的顺序性。

- 将内存中键值对添加到内存的平衡树数据结构中（如红黑树），有时被称为内存表。

- 当内存表大于某个个阈值（几M）时，会将SSTable文件写入磁盘。由于树结构维护了按键排序的key-value对，可以快速的写入磁盘。写入磁盘的同时，新的写入可以继续添加到一个新的内存表实例。

- 读请求首先尝试在内存表中查询数据，然后是最新的磁盘文件，一步一步的按段时间接近的查询。

- 后台进程周期性的合并与压缩多个段文件，并丢弃哪些被覆盖和被删除的值。

每次对内存的写入都会同步到磁盘。如果数据库崩溃，就从文件中恢复内存表。

### SSTables构建LSM-Tree

**基于合并和压缩排序文件原理**的引擎叫做LSM存储引擎，LeavelDB和RocksDB 的关键值存储引擎都使用了这种算法。Elasticsearch和Solr的全文搜索的索引引擎Lucene使用了类似的方法来存储，全文索引的值保存了该索引的键(单词)出现的所有文档索引。

#### 性能优化

- 使用布隆过滤器(Bloom) 优化数据库不存在键需要遍历全表的问题。

- 使用不同策略确定SSTables压缩和合并的顺序和时间。最常用大小分层压实（Hbase），或平坦压缩（LeavelDB和RocksDB）。

### B树

像SSTables一样，B树保持按键排序的键值对，这允许高效的**键值查找**和**范围查询**。但B树有着非常不同的设计理念。

B树将数据库分解成固定大小的块或**页面**，默认为4KB，每次只能读取或写入一个页面。每个页面使用地址或位置标识，允许一个页面引用另一个页面（类似于在磁盘中的指针）。我们可以通过页面引用构建一个页面树。

#### B树索引寻找键

在B树上根据键在**区间引用**中一级一级找到包含**键**的**页面**，该页包含每个内联键的值或包含可以找到值的页的引用。

**更新**键的值时， 寻找到包含该键的叶子页面更改该键的值。如果是添加新键，找到包含新键的页添加进去。如果该页没有足够的空间，将其分离为两个半满的叶子页面。

算法确保树保持平衡：具有n个键的B树的深度总是O(log n)。

#### **B树的可靠性**

为了数据库能从崩溃中恢复且不丢数据，B-tree通常需要额外的操作-预写日志（WAL），与写日志追加记录B-tree的操作。该日志可以将B-tree恢复到最近一致的状态。

B-tree通过锁存器（轻量级的锁）对B-tree进行并发控制。

#### B树的优化方案

- 有的数据库放弃使用覆盖页和维护WAL进行崩溃恢复，而是使用写时复制方案。修改的页被写入新的位置，修改完成后将父页的页面引用指向新的位置。如"快照隔离与可重复读"。

- 保存键的缩略信息，这样可以节省页空间。当键（非叶子节点）只描述键的起止范围，就可以让更多的键压入中间页中，让树有更高的分支因子，从而降低树的层数。

- 尝试使用布局使相邻的子页在磁盘上也是相邻的位置，但随着树的增长维持整个顺序会越来越困难。

- 添加额外的指针指向叶子叶面的相邻子页，这样当顺序扫描键的时候就不需要回到父页。

- B-tree的变体如分形树，借鉴了日志结构的想法来减少磁盘寻道。

#### 对比B-tree和LSM-tree

B-tree必须至少写两次数据：一次预写日志，一次写入页本身。当页中只有几个字节更改，也需要承担整个页的开销。LSM-tree比B-tree能承受更大的写入速率，因为LSM-tree是在文件后面**顺序写入**SSTable，而不需要重写整个文件。

日志结构的缺点是压缩过程中会干扰正在进行的读写操作，磁盘的并发资源有限，当磁盘正在进行压缩操作时，容易发生读写请求等待的情况。需要额外的监控措施监控这种情况。

B-tree能提供强大的事务语义，当需要使用事务时就需要选择B-tree类型的数据库。

### 其他索引结构

**二级索引**：将表中非主键列加为二级索引，跟主键索引的区别是通常它的键不是唯一的。

**聚簇索引**：通常是主键。

**覆盖索引：**在索引中保存一些列的值，它支持只通过索引就可以回答某些简单查询。

**多列索引：**又称级联索引，将几个字段组成一个键，遵守索引的及左原则。

**模糊索引**：。。。

**内存缓存：**在内存中保存所有内容（如Redis），为了备份防止崩溃持久化，读取全靠内存服务。内存数据库能够使用各种数据结构，支持各种特殊的功能。

**非易失性存储（NVM）**

### 事务处理与分析处理

事务处理（OLTP）保证了业务系统的正确性，分析处理（OLAP）能够对业务系统的数据进行**分析**从而得到更好的运营策略。

#### 数据仓库：

企业将所有的数据都存储在数据仓库中，数据仓库包含了所有OLTP系统的只读副本， 从OLTP数据库中提取-转换-加载（ETL），将数据存入数据仓库中。

数据仓库的数据模型常见的是关系型，因为SQL适合分析查询。有些图形化工具能直接生成SQL查询、可视化结果并支持分析师探索数据。如向下钻取、切片、切丁等操作。

#### 星型与雪花型分析模式：

事实表与维度表，星型模式维度表只有一层，雪花模式维度表可能还外键连接结了新的维度表。

#### 列式存储：

底层将每列的所有值存储在一起，每个值与行的主键关联。列存储中，也是按插入顺序保存。但每行的单独排序是没有意义的。但可以将需要排序的列加为排序键，多列则加多行字段。

#### 聚合：

数据仓库具有聚合函数，对于临时分析查询，列存储要快得多。

**物化视图**：查询后的缓存副本，被写到磁盘。当底层数据发生变化时，物化视图也需要随之更新。数据库会自动执行，但是会影响写入性能。物化视图查询非常快，因为它已经被预先计算出来。但是物化数据缺乏原始数据的灵活性，无法查询维度之外的数据聚合。

### 小结

OLTP系统面向用户，可能会收到大量的请求，应用程序基于某个键来查询数据，而数据库使用索引来查询数据，硬盘寻道时间一般是瓶颈。

OLAP不直接面向用户，数据仓库和类似的分析系统处理的请求树木远低于OLTP系统。但对查询要求苛刻，需要在短时间内扫描百万条记录，磁盘带宽通常是瓶颈。