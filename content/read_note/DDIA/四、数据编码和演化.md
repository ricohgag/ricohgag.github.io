+++
title = 'DDIA-Part4: 数据编码和演化'
date = 2020-11-10T11:14:33+08:00
draft = true
+++

应用程序的更新会随时间而变化、调整。当发生版本修改时，我们需要用可演化的思维去构建可适应变化的系统。

大多数情况下更改应用程序的功能需要更改存储的数据结构。当数据机构或模式发生改变时，经常对应代码层次的调整：

- 对于服务端应用程序需要滚动升级，每次发布新版本到少部分节点，然后逐步更新所有节点的程序。从而实现不停机更新。

- 对于客户端则无法控制他们的更新操作。

这意味着新旧版本的代码会同时运行在系统中，所以要考虑系统保持双向的兼容性：

- 向后兼容：较新的代码能够兼容之前的数据格式。

- 向前兼容：较旧的代码能够兼容新的数据格式。

### 数据编码格式

程序通常使用两种不同的数据表示形式：

1. 在内存中，数据保存在对象、结构体、列表、数组、哈希表等数据结构中，这些数据结构对CPU的高效访问和操作进行了优化（指针）。

2. 当数据写入文件或通过网络发送时，必须将其编码为某种字包含的字节序列。

因此这两种表示形式之间需要进行转化，从内存中的数据结构序列化为某种编码，相反的过程叫反序列化。

### 语言的特定模式

编程语言内置了序列化库。

- 语言的特定模式会和特定的语言绑定起来，另一种语言访问起来很困难。

- 如果解码能够实例化任意的类，那么会出现远程执行任意代码等漏洞。

- 语言的特定模式一般会忽略向前和向后的兼容性问题。

- 编码或解码需要的CPU时间及编码结构的大小问题。

### JSON、XML和二进制变体

JSON、XML和CSV虽然有些缺点，但是也用于了很多方面，如远程数据交换格式。

#### 二进制编码

**MessagePack**：略小于JSON，保留了字段名和类型。

**Thrift：**需要模式，取消了字段名

1. BinaryProtocol：每个字段又一个类型注释，取消了字段名，使用标签号代表字段。

2. CompactProtocol：类上，将字段类型和标签号存入单字节中。使用可变长度保存值。

**Protocol Buffers：**与CompactProtocol类似。

**字段标签和模式演化**

模式不可避免的随着时间不停的改变。**添加字段**时，之前的程序没有当前字段的标记会忽略此字段。这样可以实现**向前兼容性**。

每个字段都有一个唯一的标记，新的代码总是可以读取旧的数据，但不能使字段为required，删除字段则相反，从而实现**向前兼容性**。

**AVRO**

AVRO也是另一种二进制编码格式，它有两种模式语言：一种AVRO IDL用于人工编辑，另一种（基于JSON）易于机器读取。

写模式与读模式：Avro的写模式与读模式不必相同，只要保持兼容即可。模式通过字段名匹配字段，如果读取的字段不处于读模式下则忽略，如果读模式有，写模式没有则填充读模式声明的默认值。

模式演化规则：

为了保持兼容性，只能添加或删除具有默认值的字段，如果要添加没有默认值的字段，旧的reader无法读取新的writer写入的数据因此破坏向前兼容性。

writer模式的选择：

- 具有单独写入的数据库：在数据库中，不同的时间点使用不同的writer模式编写。最简单的解决方案是在每个编码记录中保留一个模式版本号，并在数据库中保存所有模式的列表，reader可以获取记录，提取版本号，从数据库中查询当前模式版本的writer模式。

- 通过网络连接发送记录：建立连接时协商模式版本，然后连接的声明周期中使用此版本模式，也就是Avro RPC协议的基本原理。

#### 模式的优点

- 比二进制JSON更紧凑，可以省略编码数据中的字段名。

- 模式是有价值的文档形式。

- 模式数据库允许在部署任何内容前检查模式更改的向前和向后兼容性。

- 静态语言能够直接从模式生成代码，能帮助编译时进行类型检查。

### 数据流模式

- 基于数据库的数据流

- 基于服务的数据流

- 基于消息的数据流

