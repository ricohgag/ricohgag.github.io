<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>SRE书单</title><url>/book_list/sre%E4%B9%A6%E5%8D%95/</url><categories/><tags/><content type="html"> Awesome 网站可靠性工程 精选的站点 可靠性 和 生产工程 资源列表。
什么是站点可靠性工程？ “从根本上说，当您要求软件工程师设计操作功能时，就会发生这种情况。” -Ben Treynor Sloss，Google工程副总裁，Google SRE创始人
贡献 请先查看 贡献准则 。
内容 文化 教育 书籍 招聘 可靠性 监视与可观测性与警报 值班 发布验证 容量规划 服务水平协议 性能 杂项文章 博客 会议 推特 SRE工具 SRE干货 文化 什么是站点可靠性工程？ KBen Treynor撰写的SRE关键点 谷歌SRE资源 Pedro Canahuati的生产工程说明 PostOps：从运营中恢复 喜欢DevOps？等到您遇到SRE [video] Google如何进行行星规模基础设施的行星规模工程 Facebook的站点可靠性工程 Uber网站可靠性工程的历史 案例研究：在StackOverflow上采用SRE原则 Dropbox的站点可靠性工程 站可靠性工程师-保持Google 24/7全天候运行 Salesforce的站点可靠性工程 从Sys Admin到Netflix SRE - video and slides SRE@Google：自2004年以来已有数千个DevOps 交易系统管理正在杀死我们，必须停止 SRE需求的层次结构 PostOps：软件，脆弱性和可靠性的非手术故事 组成出色的SRE团队 在Google工作：与我们的生产工程师见面进行现场可靠性直播 辛劳：每个工程师都应该知道的一句话 网站的工程可靠性：Google SRE DEVOPS＆SRE AMA-建立高性能组织 约翰·奥尔斯帕（John Allspaw）关于事件分析和事后分析的AMA Paul Newson进行站点可靠性工程- Part 1 &amp;amp;amp; Part 2 SysAdmins如何自我贬值 SRE，名词。另请参阅：信心，信任。 tephen Weinberg的站点可靠性工程 我们是Google网站可靠性团队。我们使Google的网站正常运行。询问我们任何事情！ 我们是Google网站可靠性工程团队。询问我们任何事情！ Ops身份危机 大型生产系统中错误的不可再现性 谈现场可靠性工程 微服务，DevOps和生产复杂性 Google客户可靠性工程简介 进化还是叛逆？站点可靠 …</content></entry><entry><title>编程中文书籍索引</title><url>/book_list/%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E7%B4%A2%E5%BC%95/</url><categories/><tags/><content type="html"><![CDATA[  免费的编程中文书籍索引，欢迎投稿。
国外程序员在 stackoverflow 推荐的程序员必读书籍， 中文版 。 stackoverflow 上的程序员应该阅读的非编程类书籍有哪些？ 中文版 github 上的一个流行的编程书籍索引 中文版 编程网站 AICodeConvert 可以将自然语言转为代码实现 可以将已有语言代码转为另一种代码语言 可以代码debug、优化、解释 目录 语言无关类
操作系统 智能系统 分布式系统 编译原理 函数式概念 计算机图形学 WEB服务器 版本控制 编辑器 NoSQL PostgreSQL MySQL 管理和监控 项目相关 设计模式 Web 大数据 编程艺术 游戏引擎 算法 其它 语言相关类
Android APP AWK C/C++ C# Clojure CSS/HTML Dart Elixir Erlang Fortran Go Groovy Haskell iOS Java JavaScript Kotlin LaTeX LISP Lua OCaml Perl PHP Prolog Python R Ruby Rust Scala Shell Swift 读书笔记及其它 测试相关 置顶 [笔记]前端工程师的入门与进阶 &amp;#x1f4af; [全文]如何正确的学习 Node.js &amp;#x1f4af; 操作系统 开源世界旅行手册 鸟哥的Linux私房菜 The Linux Command Line (中英文版) Linux 设备驱动 (第三版)&amp;#x1f61f; 深入分析Linux内核源码 &amp;#x1f61f; UNIX TOOLBOX &amp;#x1f61f; Docker中文指南 Docker —— 从入门到实践 Docker入门实战 &amp;#x1f61f; Docker Cheat Sheet FreeRADIUS新手入门 &amp;#x1f61f; Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) &amp;#x1f61f; 嵌入式 Linux 知识库 (eLinux.org 中文版) &amp;#x1f61f; 理解Linux进程 命令行的艺术 SystemTap新手指南 操作系统思考 返回目录 智能系统 一步步搭建物联网系统 返回目 …  ]]></content></entry><entry><title>程序员做饭指南</title><url>/book_list/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%9A%E9%A5%AD%E6%8C%87%E5%8D%97/</url><categories/><tags/><content type="html"> 做菜之前 厨房准备 如何选择现在吃什么 高压力锅 去腥 食品安全 微波炉 学习焯水 学习炒与煎 学习凉拌 学习腌 学习蒸 学习煮 菜谱 家常菜 素菜 拔丝土豆 白灼菜心 包菜炒鸡蛋粉丝 菠菜炒鸡蛋 炒滑蛋 炒茄子 炒青菜 葱煎豆腐 脆皮豆腐 地三鲜 干锅花菜 蚝油三鲜菇 蚝油生菜 红烧冬瓜 红烧茄子 虎皮青椒 话梅煮毛豆 鸡蛋羹 微波炉鸡蛋羹 蒸箱鸡蛋羹 鸡蛋火腿炒黄瓜 茄子炖土豆 茭白炒肉 椒盐玉米 金针菇日本豆腐煲 烤茄子 榄菜肉末四季豆 雷椒皮蛋 凉拌黄瓜 凉拌木耳 凉拌莴笋 凉拌油麦菜 麻婆豆腐 蒲烧茄子 芹菜拌茶树菇 陕北熬豆角 上汤娃娃菜 手撕包菜 水油焖蔬菜 素炒豆角 酸辣土豆丝 糖拌西红柿 莴笋叶煎饼 西红柿炒鸡蛋 西红柿豆腐汤羹 西葫芦炒鸡蛋 小炒藕丁 洋葱炒鸡蛋 荤菜 白菜猪肉炖粉条 带把肘子 冬瓜酿肉 番茄红酱 干煸仔鸡 宫保鸡丁 咕噜肉 荷兰豆炒腊肠 黑椒牛柳 简易红烧肉 南派红烧肉 红烧猪蹄 湖南家常红烧肉 黄瓜炒肉 黄焖鸡 徽派红烧肉 回锅肉 尖椒炒牛肉 姜炒鸡 姜葱捞鸡 酱牛肉 酱排骨 椒盐排条 咖喱肥牛 烤鸡翅 可乐鸡翅 口水鸡 辣椒炒肉 老式锅包肉 冷吃兔 荔枝肉 凉拌鸡丝 萝卜炖羊排 麻辣香锅 麻婆豆腐 梅菜扣肉 奶酪培根通心粉 啤酒鸭 黔式腊肠娃娃菜 青椒土豆炒肉 肉饼炖蛋 杀猪菜 山西过油肉 商芝肉 瘦肉土豆片 水煮牛肉 水煮肉片 蒜苔炒肉末 台式卤肉饭 糖醋里脊 糖醋排骨 土豆炖排骨 无骨鸡爪 西红柿牛腩 西红柿土豆炖牛肉 乡村啤酒鸭 香干芹菜炒肉 香干肉丝 香菇滑鸡 香煎五花肉 小炒黄牛肉 小炒鸡肝 小炒肉 新疆大盘鸡 血浆鸭 羊排焖面 洋葱炒猪肉 意式烤鸡 鱼香茄子 鱼香肉丝 枝竹羊腩煲 猪皮冻 猪肉烩酸菜 柱候牛腩 孜然牛肉 醉排骨 水产 白灼虾 鳊鱼炖豆腐 蛏抱蛋 葱烧海参 葱油桂鱼 干煎阿根廷红虾 红烧鲤鱼 红烧鱼 红烧鱼头 黄油煎虾 烤鱼 芥末黄油罗氏虾 芥末黄油罗氏虾 咖喱炒蟹 鲤鱼炖白菜 清蒸鲈鱼 清蒸生蚝 水煮鱼 蒜蓉虾 糖醋鲤鱼 微波葱姜黑鳕鱼 香煎翘嘴鱼 小龙虾 油焖大虾 早餐 茶叶蛋 蛋煎糍粑 桂圆红枣粥 鸡蛋三明治 煎饺 金枪鱼酱三明治 空气炸锅面包片 美式炒蛋 牛奶燕麦 水煮玉米 苏格兰蛋 太阳蛋 溏心蛋 吐司果酱 微波炉蛋糕 微波炉荷包蛋 燕麦鸡蛋饼 蒸花卷 蒸水蛋 主食 炒方便面 炒河粉 炒凉 …</content></entry><entry><title>面经书单</title><url>/book_list/%E9%9D%A2%E7%BB%8F%E4%B9%A6%E5%8D%95/</url><categories/><tags/><content type="html"> advanced-java</content></entry><entry><title>生活与健康书单</title><url>/book_list/%E7%94%9F%E6%B4%BB%E4%B8%8E%E5%81%A5%E5%BA%B7%E4%B9%A6%E5%8D%95/</url><categories/><tags/><content type="html"> 人体系统调优不完全指南 程序员延寿指南</content></entry><entry><title>First</title><url>/posts/first/</url><categories/><tags/><content type="html"> ABC啊地方</content></entry><entry><title>关于</title><url>/about/</url><categories/><tags/><content type="html"> ricohgag 最低级INTP，无时无刻不在想放弃，每时每刻都在拖延，自我认知为废物，单身狗一只；唯胜在心态乐观，信老子，不信道教，客观唯物主义者。
积极思考存在，不会给时间赋于意义，也不想给岁月以文明，好好享受活着，毕竟在时间刻度上只有这一段是真正属于你的。</content></entry><entry><title>DDIA-Part8: 分布式系统挑战</title><url>/read_note/ddia/%E5%85%AB%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8C%91%E6%88%98/</url><categories/><tags/><content type="html"> 故障与部分失效 分布式系统中，可能会出现系统一部分工作正常，但某些部分出现难以预测的故障，即部分生效。正是不确定性和部分失效提高了分布式系统的复杂性。
不可靠的网络 请求丢失
远程节点异常
响应丢失
现实中的网络故障 检测故障 超时与无限期延迟 网络拥塞与排队 同步与异步网络 不可靠的时钟 单调时钟与墙上时钟 时钟同步与准确性 依赖同步的时钟 进程暂停 理论系统模型与现实 同步模型
部分同步模型
异步模型
崩溃-中止模型
崩溃-恢复模型
拜占庭失效模型</content></entry><entry><title>DDIA-Part7: 事务</title><url>/read_note/ddia/%E4%B8%83%E4%BA%8B%E5%8A%A1/</url><categories/><tags/><content type="html"> 事务指的是满足 ACID 特性的一组操作，事务中的读写是一个执行整体，要么整个成功提交，要么全部失败回滚。
深入理解事务 ACID的含义 原子性（Atomicity） 事务被视为最小单元，事务的所有操作要么全部提交成功，要么全部回滚失败。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
一致性（Consistency） 一致性主要指事务对数据有特定的预期状态，任何数据更改必须满足这些状态约束。（如银行转账，转入和转出应该保持平衡）
隔离型（Isolation） 并发执行多个事务时相互隔离，一个事务在最终提交前对其他事务是不可见的。
持久性（Durability） 事务提交后，事务做出的修改会持久化到本地磁盘而不用担心数据丢失。
单对象和多对象事务操作 单对象写入：单对象写入也同时满足原子性和隔离性。
多对象事务的必要性
处理错误与终止
隔离级别 未提交读 事务中的修改即使没有提交，对其他事务也是可见的。
提交读 一个事务只能读取已经提交的事务所做的修改，即一个事务所做的修改在提交之前对其他事务是不可见的。可以防止脏读，脏写。
快照级别隔离和可重复读 保证在同一个事务中多次读取同一数据结果是一样的。可以解决不可重复读问题。
实现快照隔离 使用多版本并发控制（MVCC），在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。
用于实现提交读和可重复读两种级别。MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。
一致性快照的可见性原则 当事务读取数据库时，通过事务id可以决定哪些对象可见，哪些不可见。
索引与快照级别隔离 索引直接指向对象的所有版本，过滤对当前事务不可见的版本。
采用追加/写时复制技术，当需要更新时，不会修改现有页面，总是创建新的页面，让父节点指向新创建的节点。
可串行化 强制事务串型执行，多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，保证同一时间只有一个事务执行。
两阶段加锁 实现两阶段加锁 一个事务对数据对象加了X锁，就可以对A读取和更新，期间其他事务不能对A加锁。
一个事务对数据对象加了S锁，其他事务只能对A加S锁，不能加X锁。
意向锁 任意 IS/IX 锁之间都是兼容的，因 …</content></entry><entry><title>DDIA-Part6: 数据分区</title><url>/read_note/ddia/%E5%85%AD%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/</url><categories/><tags/><content type="html"> 每条数据值属于某个特定分区，不同分区可以放在一个无共享集群的不同节点上。分 区的主要目的是将数据和查询负载均匀分布在所有节点上，提高可扩展性。
如果分区不均匀，会出现倾斜。倾斜会导致分区效率严重下降，在极端情况下，所有的负载可能会集中在一个分区节点上，这种负载严重不成比例的分区即成为系统热点。
数据分区与数据复制 分区和复制结合使用，每个分区在多个节点上都存有副本。某条数据属于特定的分区，但同样的数据会以复制的方式保存在不同的节点上以提高系统的容错性。
键-值数据的分区 基于关键字区间分区 为每个分区分配一段连续的关键字或关键字区间范围，分区内可以按关键字排序保存，可以支持区间查询。
缺点是某些访问模式会导致热点（时间戳），可以使用多个字段组合作为关键字，将热点数据隔离。
基于关键字哈希分区 一个好的哈希函数可以处理数据倾斜并使其均匀分布，为每个分区分配一个hash范围，关键字根据哈希值划分到不同分区中。
通过哈希分区，我们失去了区间查询特性。可以通过复合主键建立高效的区间查询（第一部分用于哈希，其他列用作组合索引对数据排序）。
负载倾斜与热点 基于哈希的分区方法可以减轻热点，但无法做到完全避免。一个极端情况是所有的读/写都是针对同一个关键字，最终请求都将被路由到同一个分区。（【读】如社交网站上一些名人发布一些热点事件可能会引发一场访问风暴，【写】大量用户对这件热点事件id进行评论）。
这种情况只能靠应用层来减轻倾斜程度，比如在关键字后增加随机数，从而分配到不同分区。但是滞后的读取都必须从所有分区中读取数据再合并。这通常只对少量的热点关键字才有意义，对写入吞吐量低的大多数关键字都是不必要的开销。
分区与二级索引 二级索引通常不能唯一标识一条记录，通常用来加速特定值的查询，如查询红色的汽车。
二级索引是关系型数据库的必备特性，在文档数据库中应用也非常普遍。但是因为其复杂性，许多键-值存储并不支持二级索引（如HBase和Voldemort），也有些也开始支持二级索引。二级索引技术还是Solr和ElasticSearch等全文索引服务器的根本。
二级索引的主要挑战是它们不能规整的映射到分区中，主要有两种方法支持对二级索引分区。
基于文档分区的二级索引 每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档。每当需要写数据库时（新增、修改、删除），只需要处理包含 …</content></entry><entry><title>DDIA-Part5: 数据复制</title><url>/read_note/ddia/%E4%BA%94%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url><categories/><tags/><content type="html"> 复制指通过网络在多台机器上保存相同数据的副本。
边缘存储，降低访问延迟
部分组件故障，系统仍然可以使用，提高可用性。
扩展多台机器同时提供访问，提高读的吞吐量。
主从复制 原理：
指定某一副本为主副本（主节点），只有主节点支持写入，主节点首先将数据写入本地存储。
其他副本为从副本（从节点），主节点将新数据写入本地存储后，然后将数据更改通过日志或更改流的方式发送给所有从节点，从节点严格按照主节点的写入顺序写入本地。
客户端可以在主节点或从节点上执行查询，主节点可读写，从节点只读。
同步复制与异步复制 同步复制：主节点会等待从节点完成写入后才返回给客户端写入成功。
异步复制：主节点写入后向从节点发送消息，不用等待从节点写入完成确认。
半同步模式：数据库实践中，开启同步复制一般只会开启一个从节点同步，其他节点则是异步模式。当同步从节点不可用或性能下降，将其他从节点中的一个提升为同步模式。
配置新的从节点 在某个时间点对主节点产生一个一致性快照，避免同步主节点时锁定整个数据库。
将快照拷贝到新的从节点。
从节点连接主节点，并从快照节点开始追赶主节点。
处理失效节点 从节点失效：从节点恢复后，会从崩溃时的节点继续追赶主节点。
主节点失效：可以通过手动或自动的将从节点提升为主节点，之后的写的请求会发送给主节点。
自动切换步骤：
确认主节点失效。节点间使用心跳机制来检测主节点是否失效，一段时间内（如30s）如果没有响应，则认为该节点失效。
选举新的主节点。通过选举的方式来选举指定新的主节点，候选节点最好与原生节点的数据量差异最小，可以最小化数据丢失的风险。
重新配置系统使新主节点生效。客户端需要将写请求更改为发送到新的主节点。如果原主节点上线，系统要保证原主节点降级为从节点并认可新的主节点。
复制日志的实现 基于语句复制 主节点将记录所执行的每个操作请求，将操作语句作为日志发送给从节点。基于语句复制会有一些不适用场景：
任何调用非确定性函数的语句，如Now()、Random()等，在不同的副本可能会产生不同的值。
自增列。
有副作用的语句（如触发器、存储过程、用户定义的函数等）。
基于预写日志（WAL）传输 日志结构存储引擎，日志段在后台压缩并支持垃圾回收。
对采用覆盖写磁盘的Btree结构，每次修改会预先写入日志，如系统发生崩溃，会迅速恢复到此前一致状态。 …</content></entry><entry><title>DDIA-Part4: 数据编码和演化</title><url>/read_note/ddia/%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E5%8C%96/</url><categories/><tags/><content type="html"> 应用程序的更新会随时间而变化、调整。当发生版本修改时，我们需要用可演化的思维去构建可适应变化的系统。
大多数情况下更改应用程序的功能需要更改存储的数据结构。当数据机构或模式发生改变时，经常对应代码层次的调整：
对于服务端应用程序需要滚动升级，每次发布新版本到少部分节点，然后逐步更新所有节点的程序。从而实现不停机更新。
对于客户端则无法控制他们的更新操作。
这意味着新旧版本的代码会同时运行在系统中，所以要考虑系统保持双向的兼容性：
向后兼容：较新的代码能够兼容之前的数据格式。
向前兼容：较旧的代码能够兼容新的数据格式。
数据编码格式 程序通常使用两种不同的数据表示形式：
在内存中，数据保存在对象、结构体、列表、数组、哈希表等数据结构中，这些数据结构对CPU的高效访问和操作进行了优化（指针）。
当数据写入文件或通过网络发送时，必须将其编码为某种字包含的字节序列。
因此这两种表示形式之间需要进行转化，从内存中的数据结构序列化为某种编码，相反的过程叫反序列化。
语言的特定模式 编程语言内置了序列化库。
语言的特定模式会和特定的语言绑定起来，另一种语言访问起来很困难。
如果解码能够实例化任意的类，那么会出现远程执行任意代码等漏洞。
语言的特定模式一般会忽略向前和向后的兼容性问题。
编码或解码需要的CPU时间及编码结构的大小问题。
JSON、XML和二进制变体 JSON、XML和CSV虽然有些缺点，但是也用于了很多方面，如远程数据交换格式。
二进制编码 MessagePack：略小于JSON，保留了字段名和类型。
**Thrift：**需要模式，取消了字段名
BinaryProtocol：每个字段又一个类型注释，取消了字段名，使用标签号代表字段。
CompactProtocol：类上，将字段类型和标签号存入单字节中。使用可变长度保存值。
**Protocol Buffers：**与CompactProtocol类似。
字段标签和模式演化
模式不可避免的随着时间不停的改变。添加字段时，之前的程序没有当前字段的标记会忽略此字段。这样可以实现向前兼容性。
每个字段都有一个唯一的标记，新的代码总是可以读取旧的数据，但不能使字段为required，删除字段则相反，从而实现向前兼容性。
AVRO
AVRO也是另一种二进制编码格式，它有两种模式语言：一种AVRO IDL用于人工编辑，另一种（ …</content></entry><entry><title>DDIA-Part3: 数据存储与检索</title><url>/read_note/ddia/%E4%B8%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</url><categories/><tags/><content type="html"> 数据库核心：数据结构 文件结构，每行存储了key-value结构。增加新内容追加到文件尾部。旧版本的值不会被覆盖，寻找最后一次出现的键为最新的值。避免用尽磁盘，将追加的文件分为多段，将之前已经写入完成的段压缩（同key值只保留最后一个）。 哈希索引 哈希索引是key-value类型的索引，将追加文件中的key-文件偏移量（存储位置）缓存到内存中。也是Bitcask的核心做法。适合每个键的值频繁更新的场景。
哈希索引缺点
哈希表索引必须全部放入内存，内存容量决定了键的多少。但在磁盘上维护hashmap需要大量的随机访问IO，性能很差。
区间查询效率不高，只能逐个查询每一个键比对。
SSTables和LSM-Tree SSTalbes（排序字符表）：LevelDB和RocksDB
要求key-value对的顺序按键排序，且每个合并的段文件中每个键只能出现一次。
合并段更简单高效，两个段文件合并，当出现重复的键值时，采用后面时间创建的段文件中的值。
在文件中查找特定的键时，不需要在内存中保存所有键的索引，只需要保存稀疏的区间索引。可以得到特定键的前和后键的偏移地址，可以从前往后直到找到特定的键或特定键后面的键（没有此键）。
优化：可以按稀疏索引的区间将key-value值保存到一个块中，稀疏索引的每个条目执行压缩块的开头。可以减少磁盘IO次数。
SSTalbes（排序字符表）：LevelDB和RocksDB
要求key-value对的顺序按键排序，且每个合并的段文件中每个键只能出现一次。
合并段更简单高效，两个段文件合并，当出现重复的键值时，采用后面时间创建的段文件中的值。
在文件中查找特定的键时，不需要在内存中保存所有键的索引，只需要保存稀疏的区间索引。可以得到特定键的前和后键的偏移地址，可以从前往后直到找到特定的键或特定键后面的键（没有此键）。
优化：可以按稀疏索引的区间将key-value值保存到一个块中，稀疏索引的每个条目执行压缩块的开头。可以减少磁盘IO次数。
构建和维护SSTables
使用常用的内存排序数据结构（如红黑树或AVL数）保证任意顺序插入键的顺序性。
将内存中键值对添加到内存的平衡树数据结构中（如红黑树），有时被称为内存表。
当内存表大于某个个阈值（几M）时，会将SSTable文件写入磁盘。由于树结构维护了按键排序的key-value对，可以快速的 …</content></entry><entry><title>DDIA-Part2: 数据模型与查询语言</title><url>/read_note/ddia/%E4%BA%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</url><categories/><tags/><content type="html"> 概述 数据模型是开发软件最重要的部分，对软件编写方式和对思考待解决的问题都具有深远的影响。复杂的应用程序会有很多中间层，一层一层的基于下层的API构建上层API，每层抽象的提供简洁的数据模型来的隐藏下层的复杂性。本章将介绍一系列用于存储和查询的通用数据模型，将特别比较关系模型、文档模型和基于图的数据模型，还会讨论比较多种查询语言和他的使用场景。
关系模型和文档模型 关系模型 关系模型定义了所有的数据格式：关系（表）是元组（行）的集合，在关系型数据库中查询优化器自动决定执行顺序以及使用哪些索引。
关系模型强在联结操作、多对一和多对多关系更简洁的表达。使用没有意义的id映射和标识多对一的信息，当信息需要修改时只需要修改信息本身，但文档模型需要修改所有冗余数据。消除重复是数据库规范化的核心思想。
文档模型 文档模型模式灵活，由于局部性带来较好的性能，更接近于应用程序所使用的数据结构。文档模型中一对多的数据结构不需要联结，联结能力也很弱。
如果集合的项不具有相同的结构，此时更适合无模式的文档模型：
有许多不同类型对象，将每种类型对象都保存到各自的表中不太现实。
数据结构由无法控制的外部系统决定，而且可能随时改变。
查询的数据局部性：
文档通常存储为JSON、XML或二进制的连续字符串。如果应用需要频繁访问整个文档，则存储局部性具有性能优势。如果数据被划分在多个表中，则需要进行多次索引查【‘找来检索所有数据，中间可能需要更多的磁盘IO并花费更多的时间。
局部性优势只适合同时访问文档大部分内容的场景，通常数据库会加载整个文档，访问小部分内容就很浪费。且对于文档更新时，通常会重写整个文档，这方面不利因素限制了文档数据库的适用场景。
数据查询语言 声明式查询语言抽象了具体的查询过程，将查询实现交给数据库系统的查询优化器去执行，查询优化器会决定适用哪些索引和联结，以及用何种顺序来执行查询的各个语句。
命令式API则需要告诉计算机以特定的顺序执行某些操作，效率很低且不适合并行查询。
MapReduce模型 Mongo中使用既介于声明式和命令式查询之间的语言，使用查询逻辑使用代码片段表示，这些代码片段能被处理框架重复调用。主要是基于函数式编程中的map和reduce函数实现。
Mongo2.2中增加了聚合管道的声明式查询语言的支持。
图状数据模型 图数据库适合多对多关系，图由两种对象组 …</content></entry><entry><title>DDIA-Part1: 可靠、可扩展与可维护的应用系统</title><url>/read_note/ddia/%E4%B8%80%E5%8F%AF%E9%9D%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/</url><categories/><tags/><content type="html"> 概述 现在大多数应用都是数据密集型应用，系统的关键在于数据量、数据的复杂度及数据的快速多变性。
数据密集型应用也是基于标准模块构建：
数据库：用以存储数据。
高速缓存：缓存复杂或操作代价昂贵的结果，加快下一次访问。
索引：用户可以按关键字搜索数据并支持各种过滤。
流式处理：持续发送消息至另一个进程，处理采用异步方式。
批处理：定期处理大量的累计数据。
根据需求和设计目标的差异，去组合使用适合自己应用的组件来达到我们的核心设计目标：可靠、可扩展与可维护。
数据系统 可靠性 出现意外情况（硬件、软件故障、人为失误等），系统应可以继续正常运转，虽然性能可能有所降低，但确保功能正确。
应用程序执行用户所期望的功能。
可以容忍用户出现错误或不正确的软件使用方法。
性能可以应对典型场景、合理负载压力和数据量。
系统可以放置任何未经授权的访问和滥用。
硬件故障：硬盘崩溃、内存故障、电网停电等。解决硬件故障一般的解决方案是为硬件添加冗余来减少系统故障率，如磁盘RAID，服务器配备双电源，热拔插CPU，备用电源、发电机等等。
软件错误：软件故障的bug经常隐藏在正常使用下，碰到特定的触发条件才会也引起错误。软件系统问题没有快速解决方法，只能认真的检查代码、进行全面的测试、允许进程崩溃后自动重启、监控并分析生产环境的表现等。
人为失误：系统的配置出错、服务器误操作、开发API参数的边界条件等。解决方案是：
以最小出错的方式设计系统。
想办法分离容易出错的地方、容易引发故障的接口。
充分的测试：从单元测试到集成测试以及手动测试或自动化测试等。
提供快速的恢复回滚机制。
设置监控子系统，监控系统的性能指标和错误率。
推行管理流程并培训。
可扩展性 随着数据量、流量（访问量）或复杂性上升，系统应能以一种合理的方式来匹配这种增长。
描述负载：Web服务器的qps(每秒请求处理数)、数据库写入比例、聊天室同时在线人数、缓存命中率等等。
描述性能：延迟与响应时间（延迟是请求花费在处理上的时间，响应时间是包括网络传输和请求处理时间）、响应时间的百分位数。
应对负载增加的方法：单机的垂直扩展（升级更强的配置）、无状态服务的水平扩展（无共享体系结构）。
可维护性 软件的大部分成本在于整个生命周期内持续的投入（维护与缺陷修复、监控系统的运行、故障排查、技术缺陷的完善以及责怪你就爱新功能）而非最初的开发阶 …</content></entry></search>